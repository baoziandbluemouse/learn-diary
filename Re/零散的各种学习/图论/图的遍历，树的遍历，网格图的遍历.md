---
date: 2025-10-30
---

# 图的遍历

一般来说，图的遍历使用dfs和bfs，其中，*dfs一般与联通量相关*，而*bfs则更适合最短路*


dfs:

```cpp
vector<int> g[N];

int vis[N];

int dfs(int u)

{

    vis[u] = true;

    int cnt = 1;

    for (int y : g[u])

    {

        if (!vis[y])

        {

            cnt += dfs(y);

        }

    }

    return cnt;

}
```


bfs:

```cpp
// 计算从 start 到各个节点的最短路长度

// 如果节点不可达，则最短路长度为 -1

// 节点编号从 0 到 n-1，边权均为 1

vector<int> bfs(int n, vector<vector<int>> &edges, int start)

{

    vector<vector<int>> g(n);

    for (auto &e : edges)

    {

        int x = e[0], y = e[1];

        g[x].push_back(y);

        g[y].push_back(x); // 无向图

    }

  

    vector<int> dis(n, -1); // -1 表示尚未访问到

    queue<int> q;

    dis[start] = 0;

    q.push(start);

    while (!q.empty())

    {

        int x = q.front();

        q.pop();

        for (int y : g[x])

        {

            if (dis[y] < 0)

            {

                dis[y] = dis[x] + 1;

                q.push(y);

            }

        }

    }

    return dis;

}
```


# 树的遍历

树的遍历一般是用dfs为多，*分两种情况*（都可以用dfs和bfs）：

- *树为二叉树*，就使用前序遍历，中序遍历，后序遍历
- *树为一般树*，就使用类似图的遍历,但由于*树的特性：无环连通图*，他可以不用开数组vis来记录已经过的节点

主要看看一般树

例题：[2368. 受限条件下可到达节点的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/reachable-nodes-with-restrictions/description/)

```cpp
class Solution {

public:

    int reachableNodes(int n, vector<vector<int>>& edges,

                       vector<int>& restricted) {

        vector<vector<int>> g(n + 1);

        for (int i = 0; i < n - 1; i++) {

            int u = edges[i][0], v = edges[i][1];

            g[u].push_back(v);

            g[v].push_back(u);

        }

        vector<int> restrict(n + 1, 0);

        for (auto& x : restricted) {

            restrict[x] = 1;

        }

        function<int(int, int)> dfs = [&](int u, int fa) {

            if (restrict[u]) {

                return 0;

            }

            int cnt = 1;

            for (auto& x : g[u]) {

                if (x != fa) {

                    cnt += dfs(x, u);

                }

            }

            return cnt;

        };

        return dfs(0, -1);

    }

};
```


# 网格图遍历

最简单的，主要重要的是方向数组
```cpp
int dx[] = {-1,0,1,-1};
int dy[] = {0,1,0,-1};
```

比较常见的是使用bfs来遍历