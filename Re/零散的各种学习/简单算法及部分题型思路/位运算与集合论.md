---
date: 2025-04-09
tags:
  - 位运算
---

# 前言

[分享｜从集合论到位运算，常见位运算技巧分类总结！- 讨论 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)

 在编程中，通常用哈希表来表示集合，C++用unordered_set

在集合论中，有交集，并集，包含于这些概念，如果编程实现【求两个集合的交集】，需要一个一个遍历哈希表中的元素。

我们通过使用**位运算**可以实现更高效的做法

**集合可以用二进制表示**，二进制从低到高第i位为1，表示这个i在集合中，反之，如果为0，那就是不在了例如集合{0，2，3}我们就可以表示为1101

所以，我们可以把集合压缩成一个整型数字

利用位运算「并行计算」的特点，我们可以高效地做一些和集合有关的运算。按照常见的应用场景，可以分为以下四类：

- 集合与集合
- 集合与元素
- 遍历集合
- 枚举集合

# 集合与集合

通过位运算，我们可以快速将集合术语通过编程实现

两个集合的「对称差」是只属于其中一个集合，而不属于另一个集合的元素组成的集合，也就是不在交集中的元素组成的集合。

- 交集       A&B实现
- 并集       A|B实现
- 对称差    $A\oplus B$实现
- 差          A&(~B)实现
- 差(假如B是A的子集) $A\oplus B$实现
- 包含于（判断A是否包含于B)    A&B == A 或是 A|B == B 判断



# 集合与元素

使用到了移位

<<相当于乘以$2^i$,>>相当于除以$2^i$

- 单元素集合（只有一个i） 1<< i
- 全集（有0-n-1这n个元素） (1<< n)-1
- 补集(假设全集为U，集合为S) $U \oplus S$
- 属于(判断元素i是否在集合S中) (s >> i)&1 == true (false则说明不属于)
- 添加元素（相当于S与一个单元素集合取并集） S|(1 << i)
- 删除元素  (相当于S与一个单元素集合的差) S&~(1 << i)
- 删除最小元素 S&(S-1)

```cpp
s = 101100 
s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1 
s&(s-1) = 101000 

作者：灵茶山艾府 链接：https://leetcode.cn/discuss/post/CaOJ45/

来源：力扣（LeetCode） 


```


# 遍历集合

```cpp
for (int i = 0; i < n; i++) 
{      if ((s >> i) & 1) 
	 //从0到n-1进行遍历
} 

```

```cpp
for (int t = s; t > 0; t &= (t - 1))

    {

        int i = __builtin_ctz(t);  //取集合t中的最小元素
	 //这个方法更快
    }
```


# 枚举集合


```cpp
for (int s = 0; s < (1 << n); s++)
    {

    }
```

设元素范围为[0,n-1],从空集枚举到全集U

```cpp
for (int sub = s; sub > 0; sub = (sub - 1) & s)
    {

    }
```

枚举S的所有非空子集


# 相关函数

$__builtin_popcount(s)$能够返回集合S中的1的个数

$__builtin_popcountll(s)$能够返回long long类型

bit_width((unsigned)(num)) 返回num的位长度，C++20的函数


# 如何取反

由于补码的原因，我们直接取反时往往会得到一个负数，如果我们要对一个数进行取反，可以使用异或来帮忙

首先我们要知道取反数x的位数n，然后创建一个变量mask=(1<<n)-1 ,这能使mask在n位以下所有位为1，接着取反就是s = x ^ mask


# AND的性质

1. AND 的性质是，参与 AND 的数越多，结果越小
2. 由一得出的推论：子数组的 AND，不会低于整个数组的 AND。



# 做题经验

1. 涉及到位运算就把数字拆分，按位分别考虑
2. 可以用一个cnt[31]数组来记录每位进行运算后的结果
3. -1在补码中就是1111111....111,和任何数AND都等于那个数