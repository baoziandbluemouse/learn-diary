---
date: 2025-10-15
tags:
  - kmp
---
# 字符串匹配

字符串匹配，也可以说是在一个字符串a中查询给定的字符串b。

字符串匹配有两种代码实现方法，一种叫BF，是暴力匹配，消耗$O(n*m)$的时间复杂度。

一种叫KMP算法，我们主要讲KMP算法,他的时间复杂度是$O(n+m)$

# KMP算法

字符串匹配是**主串与子串进行匹配，如果以查询来理解的话，子串就是给定的字符串**

KMP算法与BF算法的主要区别就在于，BF算法如果遇到不匹配的字符，那么当前匹配会直接*回退*，**然后从主串的下一个字符进行匹配**。而KMP算法在遇到不匹配后，会想办法保留一些正确的匹配，并且**主串的索引，是不会动的，反而去动子串的索引，这样才能实现$O(n+m)$的时间复杂度**

首先，我们规定

```cpp
str1 = "ABABABCAA"; //这是主串
str2 = "ABABC";  //这是子串
//idx从0-->(n-1),0-->(m-1)
```

我们进行匹配，当idx=4时，匹配失败，这时**我们可以保留一些匹配，子串AB与主串AB可以互相匹配，那就可以保留了**。但是，我们可以发现，我们主串*有两个AB啊，怎么确认该匹配哪一个呢？*，这里就引出了一个解决这个问题的*PM数组*

先别管PM数组要怎么计算得出，PM数组与子串是对应的，当*匹配不成功时，我们会去找最后一个匹配成功的字符对应的PM数组的值*。那么例子中我们就是看idx=3的B,$PM[3]=2$,那么我们的*子串能直接跳过两个字符*，**所以PM数组中的值代表子串中我们可以跳过匹配的字符个数**，

接下来我们仍不管PM数组的实现，先来看看这一块要怎么实现代码


```cpp
int kmp_search(str,patt){
	//str是主串，patt是子串,即pattern（模式）
	pm = build_pm(patt) //假设pm已经计算完毕了
	int i = 0; //主串的idx
	int j = 0; //子串的idx
	while (i < str.size()){
		if(str[i] == str[j]){
			//字符匹配，二者都可以后移
			i++;
			j++;
		}else if(j > 0){
			//j>0，代表子串至少第一个字符被匹配成功了，那么我们就使用kmp算法
			j = pm[j-1];
		}else{
			//第一个字符就匹配失败了，那就直接用BF算法的移动主串就好了
			i++;
		}
		
		if(j == patt.size()){
			//匹配成功
			return i-j; 
			//这个相减会得到主串中子串的第一个匹配项的下标
		}
	}
}
```


**现在我们已经完成了kmp算法的一部分，接下来就是pm数组的生成了**

首先我们来想下为什么能跳过呢？观察子串，我们可以发现，其实这个跳过**是一种代替，因为子串的前两个字母和后两个字母**是一样的，那就能让前两个字母去匹配主串，后两个字母空出来，**毕竟当前匹配已无法实现正确了，那么后两个字母空出来，才有可能有更多可能性去实现正确匹配**。

所以，我们现在会发现，其实这个pm数组，关注的是**子串（注意这里只涉及子串）中的相同前缀和相同后缀的事情**，$pm[i]$代表了，*patt的子串以$patt[i]$为结尾，其相同的最长前缀与最长后缀的长度*，就是这个长度，用来移动patt的idx。*至于为什么要最长，那当然是为了节省时间复杂度了*。

现在我们知道这个pm数组怎么来的了，问题简化为了求**以$patt[i]$为结尾，其相同的最长前缀与最长后缀的长度**

pm数组的全称是(Partial Match Table)部分匹配表。另外，在数据结构一书中，还有个以此得来的next表，这里不额外补充。

然后，这个前缀和后缀的计算，也是有讲究的，要用的是*真前缀，真后缀*

假设一个字符串abbaab,我们的*idx指向最后一个字母*,即idx=5 (0 -> (n-1))

- 真前缀：a,ab,abb,abba,abbaa  即（**不包含idx指向的最后一个字符**）
- 真后缀：b,ab,aab,baab,bbaab  即（**不包含第一个字符**）

用这种计算相同前后缀也是有道理的，毕竟不用这个的话**就会得到整个子串为前缀和后缀的情况**，那样就计算不出最长相同前缀后缀了。

然后，我们要如何以一个优秀的时间复杂度求出pm数组呢？

**我们可以采用一种递推的方式来求得**，以一个$O(m)$的时间复杂度解决(下面讲的前缀后缀都是真前缀，真后缀)

首先，我们用一个变量Match来记录当前的共同前后缀，并将其长度设为cnt
patt = A B A C A B A B 
pos = 0 1 2 3 4 5 6 7

假设当前cnt = 2 , Match = AB (实际无需Match)

1. idx++,增加一个字符，判断有没有更长的共同前后缀
2. 分出两种情况
- 新增字符构成的新后缀与更长的前缀匹配，cnt+1,Match = ABA
- 新增字符不同，不匹配，比如前缀ABAC与后缀ABAB，就是不匹配的。即原来的最长公共前后缀失配。*这时候我们要做的事情就是，找上一次匹配中次长的公共前后缀，看与 7 号位的 B 拼接起来是否能匹配*。

- 不匹配的具体思想：这时候，注意到上一次扫描中 0 ~ 2 位的 ABA 是和 4 ~ 6 位的 ABA 完全相同的（贪心原则保证上次结果一定是包含前一位置字符的最长公共前后缀），所以**考察上一次匹配中次长的公共前后缀，只能在考察上一次匹配中的最长公共前后缀中考察**，也就是说，*只能考察 ABA 中更短的 BA、A 是否是次长的*，而这*直接在前面一个 ABA 中考察都行*，所以我们把 ABA C ABA 中中间部分（C）和后缀（ABA）直接抛弃，*等效于一个串 ABA（也就是前缀）与 B 拼接成 ABAB*。这样*再来计算第 7 位的 B 的 pm 值*，*等价于计算 ABAB 第 3 位的 B 的 pm 值*。


代码实现：


```cpp
vector build_pm(patt){
	//str是主串，patt是子串,即pattern（模式）
	
	//计算pm数组，假设已经初始化pm数组(用vector)
	//注意pm有一个初始元素为0
	//再次注意计算pm数组只涉及patt
	int prefix_len = 0 ; //当前共同前后缀的长度
	int i = 1 ; //代表要与前缀字符匹配的后缀字符的位置 (0-->(m-1))
	while(i < patt.size()){
		if(patt[prefix_len] == patt[i]){
			//可匹配
			prefix_len++;
			pm.push_back(prefix_len);
			i++;
		}else{
			//不可匹配，结合上面的具体思想看看
			if(prefix_len == 0){
				pm.push_back(0);
				i+=1;
			}
			else{
				prefix_len = pm[prefix_len-1];
				//结合具体思想，此时这个操作是把B与ABA拼在了一起,
				//于是共同前后缀的长度就回退了,
				//接下去再去进行匹配,就是等于在找次最长共同前后缀了。
			}
		}
	}
}
```


还有个更简化的版本:(这里pi就是pm数组)

```cpp
vector build_pm(patt){
	int m = patt.size();
    vector<int> pi(m);
    int cnt = 0;//当前共同前后缀的长度
    for (int i = 1; i < m; i++) {
        char b = patt[i];
        while (cnt && patt[cnt] != b) {
            cnt = pi[cnt - 1];
        }
        if (patt[cnt] == b) {
            cnt++;
        }
        pi[i] = cnt;
    }
}
```


# [28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

模板1：(略复杂，但易懂,如果要找出*所有匹配项，要用模板二*)

```cpp
class Solution {

public:

    int strStr(string haystack, string needle) {

        int n = haystack.size();

        int m = needle.size();

        // build_pm

        vector<int> pm;

        pm.push_back(0);

        int prefix_len = 0;

        int i = 1;

        while (i < m) {

            if (needle[prefix_len] == needle[i]) {

                prefix_len++;

                pm.push_back(prefix_len);

                i++;

            } else {

                if (prefix_len == 0) {

                    pm.push_back(0);

                    i++;

                } else {

                    prefix_len = pm[prefix_len - 1];

                }

            }

        }

        i = 0;

        int j = 0;

        while (i < n) {

            if (haystack[i] == needle[j]) {

                i++;

                j++;

            } else if (j > 0) {

                j = pm[j - 1];

            } else {

                i++;

            }

            if (j == m) {

                return i - j;

            }

        }

        return -1;

    }

};
```

模板2(*模板二他可以把text中所有和pattern匹配的都记录下来*）：

```cpp
/* 
在文本串 text 中查找模式串 pattern，返回所有成功匹配的位置（pattern[0] 在 text 中的下标）
*/
vector<int> kmp(const string& text, const string& pattern) {

    int m = pattern.size();

    vector<int> pi(m);

    int cnt = 0;

    for (int i = 1; i < m; i++) {

        char b = pattern[i];

        while (cnt && pattern[cnt] != b) {

            cnt = pi[cnt - 1];

        }

        if (pattern[cnt] == b) {

            cnt++;

        }

        pi[i] = cnt;

    }

  

    vector<int> pos;

    cnt = 0;

    for (int i = 0; i < text.size(); i++) {

        char b = text[i];

        while (cnt && pattern[cnt] != b) {

            cnt = pi[cnt - 1];

        }

        if (pattern[cnt] == b) {

            cnt++;

        }

        if (cnt == m) {

            pos.push_back(i - m + 1);

            cnt = pi[cnt - 1]; //重要

        }

    }

    return pos;

}
```