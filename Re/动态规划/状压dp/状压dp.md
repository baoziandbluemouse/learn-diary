---
date: 2025-04-09
tags:
  - 状压dp
---
# 状压dp

涉及动态规划，[[位运算与集合论]]

这类题目有排列型，还有旅行商问题（TSP）

暴力做法是枚举所有排列，对每个排列计算与题目有关的值，时间复杂度通常是$O(n!)$,可以解决n<=10的问题。

状压dp可以把时间复杂度优化至$O(n\times 2^n)$,可以解决n<=20的问题

一般有两种定义方式:

1. 定义dp[S]表示**已经排列好**的元素（下标）集合为S时，与题目有关的最优值。通过枚举当前要填的元素（下标）来转移
2. 定义dp[S]表示**可以选**的元素(下标)集合为S时，与题目有关的最优值。通过枚举当前为止要填的元素（下标）来转移


# [526. 优美的排列 - 力扣（LeetCode）](https://leetcode.cn/problems/beautiful-arrangement/description/)


## 一.寻找子问题

为方便描述，将1到n的排列perm记作p

假设n=5，回顾枚举[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)的思路，我们先不管整除的事情：

- 枚举$p_1$选哪个，它可以是1，2，3，4，5，假设$p_1$=2
- 枚举$p_2$选哪个，之前选过2就不能选2了，只能在剩余数字选，我们选$p_2=4$
- 枚举$p_3=1$
- 枚举$p_4=5$
- 枚举$p_5=3$

在这个枚举过程中，我们需要知道：

- 哪些数不能选。这可以用一个集合S存储选过的数。枚举$p_i$的值，然后把$p_i$加入集合S。注意剩下能选的数变少了，所以要解决的问题规模就变小了

从上面例子来看，到$p_3$时，之前选过的数集合S={2,4},那么就有以下几种情况：

- $p_3=1$,如果满足整除关系，那么接下来要解决的问题是:S={1,2,4}情况下，剩余数字可以构造的优美数列的数量
- $p_3=3$,如果满足整除关系，那么接下来解决的问题是:在S={2,3,4}情况下，剩余数字可以构造的优美数列的数量
- $p_3=5$，如果满足整除关系，那么接下来解决的问题是:在S={3,4,5}情况下，剩余数字可以构造的优美数列的数量

对于这种相似的子问题，我们可以考虑用递归来解决


## 二.状态转移方程

定义dp[S]为在**可以选**的数字集合为S的情况下，可以构造的优美数列

定义i为集合S中拥有的数字的大小（例如{2,3}就是2）

要解决的问题变为:  在可以选的数字集合为S \ {j}的情况下，可以构造的优美排列的数量.


$$dp[S]=\sum_{j}^{} dp[S\setminus \left \{ j \right \} ]$$


边界：

dp[0]=1

当没有可选数字时，那么我们构成的一个数列肯定是只有一个（自己排一下看看）


```cpp
class Solution {

public:

    int countArrangement(int n) {

        vector<int> dp(1 << n);

        dp[0] = 1;

        for (int s = 1; s < (1 << n); s++) {

            int i = __builtin_popcount((unsigned)s);

            for (int j = 1; j <= n; j++) {

                if (s >> (j - 1) & 1 && (i % j == 0 || j % i == 0)) {

                    dp[s] += dp[s & (~(1 << (j - 1)))];

                }

            }

        }

        return dp.back();

        // vector<int> memo((1 << n), -1); //-1表示没有计算过

        // int res = dfs(0, n, memo);

        // return res;

    }

  

    // int dfs(int s, int n, vector<int> &memo)

    // {

    //     if (memo[s] != -1)

    //     {

    //         return memo[s];

    //     }

    //     if (s == (1 << n) - 1)

    //     {

    //         //(1<<n)-1代表全集,这意味着s这个集合已经选完了全部数，那么就只有一种优美数列了

    //         return 1;

    //     }

    //     int res = 0;

    //     int i = __builtin_popcount((unsigned)s) + 1; // 当前要放置的位置

    //     for (int j = 1; j <= n; j++)

    //     {

    //         // 遍历所有数字

    //         // 这里j-1是因为，我们的s在二进制中的最低位此时不代表0，而是代表1

    //         // 所以如果要检查数字1，那么就要检查第0位

    //         // 同理，添加数字时，也要j-1

    //         if ((s >> (j - 1) & 1) == 0 && (i % j == 0 || j % i == 0))

    //         {

    //             res += dfs(s | (1 << (j - 1)), n, memo); // 把数字j添加到S中

    //         }

    //     }

    //     memo[s] = res;

    //     return res;

    // }

};
```

