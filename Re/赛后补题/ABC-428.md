---
date: 2025-10-19
---

# [C - Brackets Stack Query](https://atcoder.jp/contests/abc428/tasks/abc428_c)

本题看完知道是括号匹配，但只知道栈匹配方法，现在有一种新的数字配对方法

- 把（当作1，把）当作-1，然后对序列做前缀和，如果*中途不出现负数*，且最终*前缀和的结果是0*，说明括号序列合法。
- 简单解释：如果*中途出现了负数*，说明出现了类似状况：（（））），即存在右括号无法匹配，那么后面不管怎么加括号，都不可能变成合法。至于最终前缀和结果为0就很明显了，左括号和右括号都找到了对应匹配。
- 本题的做法就是维护括号序列的前缀和，并*动态维护前缀和途中是否出现负数*。

我们采用multiset来维护所有前缀和的最小值，只要最小值>=0,说明没出现负数。(multiset删除，查找有优化，并且自动升序排列)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 8e5 + 10;

int pre[N];

  

void solve()

{

    int q;

    cin >> q;

    int len = 0;

    multiset<int> st;

  

    while (q--)

    {

        int op;

        char c;

        cin >> op;

        if (op == 1)

        {

            len++;

            cin >> c;

            if (c == '(')

            {

                pre[len] = pre[len - 1] + 1;

            }

            else

            {

                pre[len] = pre[len - 1] - 1;

            }

            st.insert(pre[len]);

        }

        else

        {

            st.erase(st.find(pre[len]));

            len--;

        }

        if (*st.begin() >= 0 && pre[len] == 0)

            cout << "Yes\n";

        else

            cout << "No\n";

    }

}

  

int main()

{

    int _ = 1;

    // cin >> _;

    while (_--)

    {

        solve();

    }

    return 0;

}
```


# [D - 183184](https://atcoder.jp/contests/abc428/tasks/abc428_d)

永远做不会数学题，令人感叹。

假设 (C+x) 是d位数，那么x必须满足以下两个区间的交集：

- 1<=X<=D,以及
- $10^{d-1}-C<=x<=10^{d}-1-C$

令L = max(1,$10^{d-1}-C$),R = min(D,$10^{d}-1-C$)。则x的取值范围就是[L,R]。

由于我们假设(C+x)有d位数，那么f(C,C+x) = $C \times 10^{d} + (C+x)$。因此，该范围的答案就是介于$$C \times 10^{d} + (C+L)和C \times 10^{d} + (C+R)$$
之间的完全平方数的数量。

由于小于等于K的完全平方数有$\left \lfloor \sqrt{K}  \right \rfloor$个，所以我们就可以算出在一个位数d下的答案来了，只要穷举位数d，多次累积就能得到ans了

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

void solve()

{

    ll c, d;

    cin >> c >> d;

    ll ans = 0, base = 1; // base 是 10^{d-1}

    for (int l = 0; l <= 18; ++l)

    {

        ll L = max(base - c, 1ll);

        ll R = min(d, 10 * base - c - 1);

        if (L <= R)

        {

            ans += (int) sqrtl(R + c * (base * 10 + 1)) - (int) sqrtl(L - 1 + c * (base * 10 + 1));

        }

        base *= 10;

    }

    cout << ans << "\n";

}

  

int main()

{

    int _ = 1;

    cin >> _;

    while (_--)

    {

        solve();

    }

    return 0;

}
```

# [E - Farthest Vertex](https://atcoder.jp/contests/abc428/tasks/abc428_e)

这题就是用上了树的直径

(树的直径是树中任意两个节点之间最长路径的长度，这条路径上的所有节点都只访问一次。)

经典结论：对于对于一个点，距离它最远的点一定是直径的端点。

- 求出树上直径，并以直径的两个端点为根跑一遍dfs，得到树上所有点到直径端点的距离即可。
- 答案只需要和两个端点比较一下，取较长端点即可。


```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const int N = 5e5 + 10;

int dep1[N], dep2[N], dep3[N];

int mx1 = -1, rt1 = -1;

vector<int> g[N];

  

void dfs(int u, int fa, int dep[])

{

    dep[u] = dep[fa] + 1;

    for (auto v : g[u])

        if (v != fa)

        {

            dfs(v, u, dep);

        }

}

  

void solve()

{

    int n;

    cin >> n;

    for (int i = 1; i < n; i++)

    {

        int u, v;

        cin >> u >> v;

        g[u].push_back(v);

        g[v].push_back(u);

    }

    dfs(1, 1, dep1);

    int mx1 = -1, rt1 = -1;

    for (int i = n; i >= 1; i--)

    {

        if (dep1[i] > mx1)

        {

            mx1 = dep1[i];

            rt1 = i;

        }

    }

    dfs(rt1, rt1, dep2);

    int mx2 = -1, rt2 = -1;

    for (int i = n; i >= 1; i--)

    {

        if (dep2[i] > mx2)

        {

            mx2 = dep2[i];

            rt2 = i;

        }

    }

    dfs(rt2, rt2, dep3);

    for (int i = 1; i <= n; i++)

    {

        if (dep2[i] > dep3[i])

            cout << rt1 << "\n";

        else if (dep3[i] > dep2[i])

            cout << rt2 << "\n";

        else

            cout << max(rt1, rt2) << "\n";

    }

}

  

int main()

{

    int _ = 1;

    // cin >> _;

    while (_--)

    {

        solve();

    }

    return 0;

}
```

