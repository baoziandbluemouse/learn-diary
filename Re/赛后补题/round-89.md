---
date: 2025-04-13
---

# 结论

n/k向上取整可用 (n+k-1)/k

组合数结论: 

$$C_{n}^{0}+C_{n}^{2}+C_{n}^{4}.... = C_{n}^{1}+C_{n}^{3}+C_{n}^{5}.... = 2^{n-1} $$
两个合起来就是$2^n$

开灯结论：

若每次能改变两盏灯的状态，初始亮着x盏灯，操作完毕后亮y盏灯，x与y在mod2的情况下同余（即操作**不会改变亮灯数的奇偶性**）

# [小红开灯（二）](https://ac.nowcoder.com/acm/problem/292749)

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()

{

    int n;

    cin >> n;

    string s;

    cin >> s;

    int cnt = 0;

    for (int i = 1; i < n; i++)

    {

        if (s[i] == '1' && s[i - 1] == '1')

        {

            cnt++;

            s[i] = '0';

        }

    }

    cout << cnt;

    return 0;

}
```

# [小红开灯（三，easy）](https://ac.nowcoder.com/acm/problem/292751)


对同一个区间操作两次和操作零次是等价的，所以只有操作零次和一次的区别

一共n盏灯，那么就有n-k+1个区间

我们假设有n盏灯，每个区间长度就是k

那么就有[1,k],[2,k+1]...[n-k+1,n]这些区间，这些区间总共有n-k+1个

每个区间互相独立，有两种不同清空，符合乘法原理

那么答案就是$2^{n-k+1}$


# [小红开灯（三，hard）](https://ac.nowcoder.com/acm/problem/292753)

和第三题区别在于不是连续k盏，二十选出总计k盏改变

首先我们可以知道当k< N时，我们操作两次1，可以改变任意两盏灯的状态而其他不变（要么进行两次了要么进行0次）

那么操作可以任意次，所以直接可以得出我们在k< N时，可以改变任意两盏灯的状态，也可以改变任意k盏灯的状态，有两种操作方式。

再深究，当k为奇数时，结合这两种操作方式，我们可以改变任意一盏灯的状态

所以k为奇数且小于n时，我们所有情况都能达成，答案是$2^n$

当k为偶数时，我们可以发现我们永远只能改变偶数盏灯，不可能改出奇数的

那样的话，就可以用组合数得出答案了，能够达成的情况有，n盏灯改变0盏灯时的情况+n盏灯改变2盏灯的情况+n盏灯改变4盏灯的情况...一直往下，直到达到n或是达到n-1结束

我们可以用快速幂和乘法逆元求出组合数，不过没必要，根据组合数结论$$C_{n}^{0}+C_{n}^{2}+C_{n}^{4}.... = C_{n}^{1}+C_{n}^{3}+C_{n}^{5}.... = 2^{n-1} $$
最后答案是$2^{n-1}$

然后我们还有一个k=n的情况，这个答案肯定就只有2个了