---
date: 2025-08-01
---

# [D - Match, Mod, Minimize 2](https://atcoder.jp/contests/abc416/tasks/abc416_d)

要使$\sum (\left ( A_i+  B_i \right ) \mod M )$最小，观察题目，$A_i$和$B_i$ 都不会超过M，那么就代表二者之和不会超过2M,此时分类讨论

$A_i+B_i \ge  M$： 进行取余后，$ans = A_{i}+ B_{i} -M$

$A_{i}+B_{i} < M$:  进行取余后，$ans = A_{i}+B_{i}$

那么答案就可以转化为$\sum (A_i+B_i) - k \times M$,想要k越多，就要越多AB之和>M,贪心的想，就要大A值与小B值进行相加，可以使用双指针

（涉及取余的题目不仅要看N范围，也要看看数字值大小）


```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

void solve()

{

    int n, m;

    cin >> n >> m;

    ll sum = 0;

    vector<int> a(n), b(n);

    for (int i = 0; i < n; i++)

    {

        cin >> a[i];

        sum += a[i];

    }

    for (int i = 0; i < n; i++)

    {

        cin >> b[i];

        sum += b[i];

    }

    sort(a.begin(), a.end());

    sort(b.begin(), b.end());

    ll k = 0;

    int j = 0;

    for (int i = n - 1; i >= 0; i--)

    {

        while (j < n && a[i] + b[j] < m)

        {

            j++;

        }

        if (j == n)

        {

            break;

        }

        k++;

        j++;

    }

    cout << sum - k * m << "\n";

}

  

int main()

{

    int _;

    cin >> _;

    while (_--)

    {

        solve();

    }

    return 0;

}
```


# [E - Development](https://atcoder.jp/contests/abc416/tasks/abc416_e)

先不考虑机场，题目想要求任意两点的最短距离**之和**，可以使用Floyd。

Q次操作中，1操作修改了(x,y)两座城市之间的距离，那么就相当于有**经过这两个城市的路径需要修改**。我们只要判断一下这个修改就可以，枚举城市u，城市v(两个都是1->n)，先测一下(u,x)->(y,v)和(u,y)->(x,v)这两个哪个的距离更短，然后将结果与(u,v)对比一下就好了

接着考虑机场，我们可以得出，假如这个路径是最短的，有使用机场，那么一定只使用**一次**，因为机场间本来就是互达的，假如有A->B->C,那么不如直接A->C

所以我们可以求出每个城市到达最近的机场要多久,假设i点到达最近机场距离为air[i]

最后结果就分为两种情况:

没使用机场：$dis[u][v]$

使用了机场: air[u]+飞机时间+air[v]


```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 550;

using ll = long long;

bool vis[N];

  

int main()

{

    int n, m;

    cin >> n >> m;

    vector<vector<ll>> dis(n + 5, vector<ll>(n + 5, 1e18));

    for (int i = 1; i <= n; i++)

    {

        dis[i][i] = 0; // 自己到自己

    }

    for (int i = 1; i <= m; i++)

    {

        ll u, v, w;

        cin >> u >> v >> w;

        dis[u][v] = dis[v][u] = min(dis[u][v], w);

    }

    ll k, kt;

    cin >> k >> kt;

    for (int i = 1; i <= k; i++)

    {

        int x;

        cin >> x;

        vis[x] = 1;

    }

  

    for (int k = 1; k <= n; k++)

    {

        for (int i = 1; i <= n; i++)

        {

            for (int j = 1; j <= n; j++)

            {

                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);

            }

        }

    }

    int q;

    cin >> q;

    while (q--)

    {

        ll op, x, y, t;

        cin >> op;

        if (op == 1)

        {

            cin >> x >> y >> t;

            for (int i = 1; i <= n; i++)

            {

                for (int j = 1; j <= n; j++)

                {

                    ll nd = min(dis[i][x] + t + dis[y][j], dis[i][y] + t + dis[x][j]);

                    dis[i][j] = min(dis[i][j], nd);

                }

            }

        }

        else if (op == 2)

        {

            int x;

            cin >> x;

            vis[x] = 1;

        }

        else

        {

            vector<ll> air(n + 5, 1e18); // air[i]:i到最近机场的距离

            for (int i = 1; i <= n; i++)

            {

                for (int j = 1; j <= n; j++)

                {

                    if (vis[j] == 1)

                    {

                        air[i] = min(air[i], dis[i][j]);

                    }

                }

            }

            ll ans = 0;

            for (int i = 1; i <= n; i++)

            {

                for (int j = 1; j <= n; j++)

                {

                    ll cur = min(dis[i][j], air[i] + kt + air[j]);

                    if (cur < 1e18)

                    {

                        // 说明到的了

                        ans += cur;

                    }

                }

            }

            cout << ans << "\n";

        }

    }

    return 0;

}
```

