---
date: 2025-10-12
---
# [D - The Simple Game](https://atcoder.jp/contests/abc427/tasks/abc427_d)

赛时注意到k很小，但想不到怎么动态规划,事实上确实可以用记忆化搜索写出

- 当前操作的人如果想赢 **等价于** 操作后下一个人无论如何操作都会输。
- $dp[u][k][c]$定义为当前在顶点u，剩余步数为k，当前玩家希望最终字符为c（0表示A，1表示B），是否可行
- 状态转移：

如果 K = 0 ，则游戏结束，判断当前顶点字符是否等于期望字符

如果 K > 0 , 当前玩家选择出一条边从u到v

1. *当前玩家希望达到结果 c，则对手希望达到相反结果 1-c*
2. 如果存在一个后继节点v，使得下一个玩家无法在剩余k-1步内到达1-c，则当前玩家可以获胜

- 也就是对于当前状态(u,k,c),只要能达到一个状态满足$dp[v][k-1][1-c]$=0,就说明从u走到v后下一个人没法赢，那现在的人就赢了。

# [E - Wind Cleaning](https://atcoder.jp/contests/abc427/tasks/abc427_e)

一个BFS大模拟

简单思路：

- 相对坐标系：将*T的位置视为原点(0,0)，所有垃圾位置都转换为相对于T的坐标*。这样只需要检查相对位置即可。
- 状态表示：每个状态可以用当前所有垃圾的相对位置集合来表示。
- BFS：用BFS向四个方向搜，每次生成一个状态，*当有一个状态，其垃圾的位置集合为空，就相当于垃圾都被清出去了*
- 复杂度：因为所有垃圾是一起移动的，而垃圾能变成的可能性最多也就是子矩阵的个数$O(N^{2} \times M^{2})$,每个子矩阵最多也就只有$O(N \times M)$个位置可以放置，所以复杂度为$O(N^{3} \times M^{3})$

做法：

1. 对于每个状态，检查是否为空（所有垃圾消失），如果是则返回操作次数，**第一次搜到即为最小操作次数**。
2. 对于每个方向，计算所有垃圾移动后的新位置。
3. 只保留移动后仍在网格内的垃圾。
4. 对新状态**排序并去重**，避免重复搜索。


```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 15;

int dx[4] = {-1, 1, 0, 0};

int dy[4] = {0, 0, -1, 1};

  

string s[N];

  

struct node

{

    vector<pair<int, int>> vec; // 所有垃圾到T的距离

    int cnt;                    // 操作了几次

};

  

void solve()

{

    int n, m;

    cin >> n >> m;

    for (int i = 0; i < n; i++)

    {

        cin >> s[i];

    }

    int sx, sy;

    vector<pair<int, int>> vec;

    for (int i = 0; i < n; i++)

    {

        for (int j = 0; j < m; j++)

        {

            if (s[i][j] == 'T')

            {

                sx = i;

                sy = j;

            }

            if (s[i][j] == '#')

                vec.push_back({i, j});

        }

    }

    if (vec.empty())

    {

        cout << 0 << endl;

        return;

    }

    for (auto &[x, y] : vec)

    {

        x -= sx;

        y -= sy;

    }

    queue<node> q;

    q.push({vec, 0});

    map<vector<pair<int, int>>, int> vis;

    while (!q.empty())

    {

        auto [cur, cnt] = q.front();

        q.pop();

        if (cur.empty())

        {

            cout << cnt << endl;

            return;

        }

        for (int i = 0; i < 4; i++)

        {

            vector<pair<int, int>> ncur;

            int ok = 1;

            for (auto &[x, y] : cur)

            {

                int nx = x + dx[i], ny = y + dy[i];

                if (nx == 0 && ny == 0)

                {

                    ok = 0;

                    break;

                }

                int rx = sx + nx, ry = sy + ny;

                if (rx < 0 || rx >= n || ry < 0 || ry >= m)

                    continue;

                ncur.push_back({nx, ny});

            }

            if (ok == 0)

                continue;

            sort(ncur.begin(), ncur.end());

            if (!vis[ncur])

            {

                vis[ncur] = 1;

                q.push({ncur, cnt + 1});

            }

        }

    }

    cout << -1 << endl;

}

  

int main()

{

    int _ = 1;

    // cin >> _;

    while (_--)

    {

        solve();

    }

    return 0;

}
```
