---
date: 2025-10-26
---

# [D - On AtCoder Conference](https://atcoder.jp/contests/abc429/tasks/abc429_d)

首先可以发现一段连续无人的地方，对答案的影响是相同的，都等价于其之后第一个有人的地方，即可以认为$a_{i}$对答案影响了$(a_{i+1}-a_{i})$次。

- 考虑对于第i个人所处位置$a_{i}$,如何计算从他开始的答案（a数组已经提前sort过）

显然第c个比他大的人就是$a_{i+c}$,问题在于$a_{i+c}$这个位置可能有很多人，所以我们可以找到第一个大于$a_{i+c}$的人是谁，那么他的上一个人p就是最后一个$a_{i+c}$了。

说明从i开始，要走到p才可以，总共路过了p-i个人

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

using ll = long long;

ll a[N];

  

void solve()

{

    ll n, m, c;

    ll ans = 0;

    cin >> n >> m >> c;

    for (int i = 1; i <= n; i++)

    {

        cin >> a[i];

    }

    sort(a + 1, a + 1 + n);

    for (int i = 1; i <= n; i++)

        a[n + i] = a[i] + m;

    for (int i = 1; i <= n; i++)

    {

        int p = upper_bound(a + 1, a + 1 + 2 * n, a[i + c]) - a - 1;

        ans += 1ll * (p - i) * (a[i + 1] - a[i]);

    }

    cout << ans;

}

  

int main()

{

    ios::sync_with_stdio(0);

    cin.tie(0);

    int _ = 1;

    // cin >> _;

    while (_--)

    {

        solve();

    }

    return 0;

}
```



# [E - Hit and Away](https://atcoder.jp/contests/abc429/tasks/abc429_e)

早知道先做E了，E好简单

题目可以转化为：对于每个D，最近的两个S分别距离是多少，考虑如何解决这个问题

- 一般情况：从所有的S点开始BFS，第一次碰到D就说明找到了D的最短距离，第二次碰到就说明找到了次短距离。
- 特殊情况：一个S可能会对一个D同时造成两个距离，这种情况只能取最短路径。可以通过记录最短距离来源，来排除这种情况。


```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

using ll = long long;

int vis[N], f[N], ans[N];

vector<int> g[N];

// vis[i] -> 第i个点被访问的次数

// f[i] -> 点i是从哪个S过来的

// ans[i] -> 第i个点到2个最近的S 距离之和

  

void solve()

{

    int n, m;

    cin >> n >> m;

    while (m--)

    {

        int u, v;

        cin >> u >> v;

        g[u].push_back(v);

        g[v].push_back(u);

    }

    string s;

    cin >> s;

    s = " " + s;

    queue<array<int, 3>> q;

    for (int i = 1; i <= n; i++)

    {

        // 将所有S点入队

        if (s[i] == 'S')

        {

            q.push({i, 0, i}); // 当前点，已经走的距离，以及这个点是从哪个S过来的

            vis[i] = 1;

            f[i] = i;

        }

    }

    while (q.size())

    {

        auto [u, d, src] = q.front();

        // u: 当前点  d:已经走的距离  src:这个点是从哪个S过来的

        q.pop();

        for (int v : g[u])

        {

            if (vis[v] != 2 && f[v] != src)

            {

                // vis只能为0和1，表示第一次和第二次到达

                ans[v] += d + 1;

                vis[v]++;

                f[v] = src;

                q.push({v, d + 1, src});

            }

        }

    }

    for (int i = 1; i <= n; i++)

    {

        if (s[i] == 'D')

        {

            cout << ans[i] << "\n";

        }

    }

}

  

int main()

{

    ios::sync_with_stdio(0);

    cin.tie(0);

    int _ = 1;

    // cin >> _;

    while (_--)

    {

        solve();

    }

    return 0;

}
```
