---
date: 2025-04-26
---

# [Problem - D - Codeforces](https://codeforces.com/contest/2106/problem/D)

思路：


---

# 题目思路讲解

存在这样一个贪心策略：

- 每当你在序列 `a` 中遇到一朵花时，如果它的美丽度不小于下一朵你需要从 `b` 中摘取的花的美丽度，就摘取它。
    
- 如果直接在不插入新花的情况下运行这个贪心策略，能够恰好摘取所有 `m` 朵目标花，那么答案就是 **0**。
    

---

## 插入新花的意义

考虑在 `a` 中插入一朵美丽度为 `k` 的新花：

- 插入后，你可以在合适的位置摘取这朵花，相当于跳过 `b` 中某一朵要求摘取的花。
    
- 因此，与其在 `a` 中插入新元素，不如把问题转化成：**删除 `b` 中的一朵花**。
    

---

## 暴力解法（太慢）

一种慢速做法是：

- 尝试删除 `b1`、`b2`、…、`bm` 中的每一朵花。
    
- 每次删除后，在 `a` 上重新运行贪心策略，检查是否可以摘取剩下的 `m-1` 朵花。
    
- 最后，选出所有成功的删除方案中，被删掉的花美丽度的最小值作为答案。
    

**问题**：这种做法复杂度太高，无法通过。

---

## 更快的做法（双指针）

为了优化，我们定义两个辅助数组：

1. **前缀匹配 pi**
    
    对于每个 1 <= i <= m，计算最小的下标 `p[i]`，使得在 `a[1]~a[p[i]]` 上运行贪心，可以摘取 `b[1]~b[i]`。
    p[i]的值为一个长度，这个长度就是，假如我们要摘花摘到b[i]，那我们在不进行额外操作的情况下，要在a里花多少长度才能满足到b[i]
    
2. **后缀匹配 si**
    
    对于每个 1 <= i <= m，计算最大的下标 `s[i]`，使得在 `a[s[i]]~a[n]` 上运行贪心，可以摘取 `b[i]~b[m]`。
    s[i]和p[i]差不多，只不过这个是后缀
    

这两个数组可以使用**双指针**在 O(n+m) 时间内计算完成。

---

## 最后的判断条件

你可以删除 `b[j]`，当且仅当满足条件：

- `p[j-1] < s[j+1]`
    

特别地：

- 想删除 `b[1]`，只要 `s[2] > 0`
    
- 想删除 `b[m]`，只要 `p[m-1] <= n`
    

在所有满足条件的 `b[j]` 中，取它们美丽度的最小值作为答案。

如果不存在可以删除的 `b[j]`，则答案为 **-1**。

---

## 题解


```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

  

void solve()

{

    int n, m;

    cin >> n >> m;

    vector<ll> a(n);

    vector<ll> b(m);

    vector<ll> l(n, -1); // 前缀  l[i]代表的是a[i]作为被摘走的花后，下一朵要摘的b[i]花的下标

    vector<ll> r(n, -1); // 后缀

    for (int i = 0; i < n; i++)

    {

        cin >> a[i];

    }

    for (int i = 0; i < m; i++)

    {

        cin >> b[i];

    }

    int bi = 0;

    for (int i = 0; i < n; i++)

    {

        if (bi < m && a[i] >= b[bi])

        {

            bi++;

        }

        l[i] = bi;

    }

    bi = m - 1;

    for (int i = n - 1; i >= 0; i--)

    {

        if (bi >= 0 && a[i] >= b[bi])

        {

            bi--;

        }

        r[i] = bi;

    }

    if (l[n - 1] == m)

    {

        cout << 0 << endl;

        return;

    }

    ll ans = 1e18;

    // 边界处理

    if (l[n - 1] == m - 1)

    {

        ans = min(ans, b[m - 1]);

    }

    if (r[0] == 0)

    {

        ans = min(ans, b[0]);

    }

    for (int i = 0; i < n - 1; i++)

    {

        if (l[i] == r[i + 1])

        {

            ans = min(ans, b[l[i]]);

        }

    }

    if (ans == 1e18)

        cout << -1 << "\n";

    else

        cout << ans << "\n";

}

  

int main()

{

    ios::sync_with_stdio(0);

    cin.tie(0);

    int t;

    cin >> t;

    while (t--)

    {

        solve();

    }

    return 0;

}
```
