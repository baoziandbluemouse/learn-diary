---
date: 2025-09-15
---

# [D - Long Waiting](https://atcoder.jp/contests/abc423/tasks/abc423_d)

**关键点在于处理餐厅容量不足时的等待情况：当一组顾客无法立即进入时，必须等待餐厅内的某些组离开以释放空间。**

1. 使用优先队列来管理当前在餐厅中的组，存储每组离开餐厅的时间和人数
2. 当一组顾客无法进入时，从优先队列里一直取出人，直到当前这组可以进入。
3. 每组顾客最多会被取出一次，复杂度正确。

做法:

- 初始化当前剩余容量now为**K**,当前时间t为0
- 对于每组顾客(按时间顺序):

1. **检查容量**:如果now小于这组顾客的人数C，那就让队列把最早离开餐厅的小组弹出，把now加回去，直到容量符合要求，每次弹出时，更新时间t
2. **更新时间**:符合要求后，当前时间t取(**t**,这组顾客到达时间**A**)的**最大值**
3. 输出进入时间
4. 更新状态:减少now，并将该组的离开时间和人数加入优先队列


# [E - Sum of Subarrays](https://atcoder.jp/contests/abc423/tasks/abc423_e)

1. 对于求子数组和的问题，**可以考虑转换成考虑每个数字造成的贡献**:

对于每个元素$A_j$ 计算它在多少个子区间中出现,并加权求和。具体地，对于查询[L,R],**如果只看元素$A_j$答案可以表示为**:$${\textstyle \sum_{j=L}^{R}} A_j\times (j-L+1)\times (R-j+1)$$
这段数学公式的意义是对于$A_j$来说，只要左端点在[L,j],右端点在[j,R]之间,$A_j$就能造成一次贡献

我们可以看出 $A_j$​ 造成贡献的次数 = 可以包含$A_j$的左端点数量 × 可以包含$A_j$的右端点数量= (j−L+1)×(R−j+1)。

将表达式展开得到$$ A_j\times (j-L+1)\times (R-j+1) = -A_j \cdot j^{2}+A_j\cdot j(L+R)+A_j\cdot (R+1) \cdot (1-L)$$

再加上求和符号，答案就变为了一个**前缀和**问题，我们把$A_j$      $A_{j}\cdot j$      $A_{j} \cdot j^2$ 这三个计算一下前缀和，就得出答案了