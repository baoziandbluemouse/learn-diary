---
date: 2025-02-23
tags:
  - 哈希
---
# 什么是哈希

Hash感觉就是一个函数，你输入进去一个东西，例如输入字符串，他会进行处理，返回你一个值，这个值是**唯一**的，不可能通过输入其他东西出现的。

所以我们可以用Hash来做到一一对应，一个字符串对应一个哈希值。（字符哈希是最常见的，所以我们先说这个）

Hash还有一个特点就是不可逆，我们没办法通过这个返回得到的值复原出输入的东西了。所以他可用于加密啥啥的。

信息学竞赛中只会用到一种名为“BKDR Hash”的字符串Hash算法。

# BKDR Hash

它的主要思路是选取恰当的进制，可以把字符串中的字符看成一个大数字中的每一位数字，不过比较字符串和比较大数字的复杂度并没有什么区别(高精数的比较也是O(n)的)，但只要把它对一个数取模，然后认为取模后的结果相等原数就相等，那么就可以在一定的错误率的基础上O(1)进行判断了。

hash的做法：

首先设一个进制数base，并设一个模数mod

而哈希其实就是把一个数转化为一个值，这个值是base进制的，储存在哈希表中，注意一下在存入的时候取模一下即可

比如说现在有一个字符串orzc

枚举这个字符串的每一位，与base相乘得到ans，然后mod一下，就得到orzc的哈希值

但是哈希有一个很大的弊端：

**哈希冲突**

什么是哈希冲突呢？

就比如所orzc的哈希值是233，而orzhjw的哈希值也是233

那么我们在查询的时候代码会认为这两个字符串是相同的，但显然这两个字符串是不同的

减少哈希冲突的方法很多

自然溢出法，双哈希之类的

这道题的话，单哈希也是可以过的，mod定大一点就好

模数的选择（尽量还是要选择质数）：

绝大多数情况下，不要选择一个$10^9$级别的数，因为这样随机数据都会有Hash冲突，根据生日悖论，随便找上$\sqrt{10^9}$个串就有大概率出现至少一对Hash 值相等的串（参见BZOJ 3098 Hash Killer II）。

最稳妥的办法是选择两个$10^9$级别的质数，只有模这两个数都相等才判断相等，但常数略大，代码相对难写，目前暂时没有办法卡掉这种写法（除了卡时间让它超时）（参见BZOJ 3099 Hash Killer III）。

如果能背过或在考场上找出一个$10^{18}$级别的质数(Miller-Rabin)，也相对靠谱，主要用于前一种担心会超时，后一种担心被卡。

偷懒的写法就是直接使用unsigned long long，不手动进行取模，它溢出时会自动对264进行取模，如果出题人比较良心，这种做法也不会被卡，但这个是完全可以卡的，卡的方法参见BZOJ 3097 Hash Killer I。
# 例题


[P3370 【模板】字符串哈希 - 洛谷](https://www.luogu.com.cn/problem/P3370)


我们采用自然溢出的方法来写哈希

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef unsigned long long ull;

const int N = 1e4 + 9;

ull base = 131;

ull a[N];

ull s[N];

  

ull hash_h(string st)

{

    int len = st.size();

    ull ans = 0;

    for (int i = 0; i < len; i++)

    {

        ans = ans * base + (ull)st[i];

        // 枚举了字符串的每一位，将每一位与base相乘，转为base进制

        // 加(ull)是为了防止爆栈搞出一个负数，(ull)是无符号的

        // 这里不取模，让他自然溢出,定义为ull的数在超过2^32的时候会自然溢出

    }

    return ans;

}

  

int main()

{

    ios::sync_with_stdio(0);

    cin.tie(0);

    cout.tie(0);

    int n;

    cin >> n;

    string st;

    for (int i = 1; i <= n; i++)

    {

        cin >> st;

        a[i] = hash_h(st);

    }

    sort(a + 1, a + 1 + n);

    ull ans = 1; // 一定至少有一个

    for (int i = 1; i < n; i++)

    {

        if (a[i] != a[i + 1])

        {

            ans++;

        }

    }

    cout << ans << "\n";

    return 0;

}
```
