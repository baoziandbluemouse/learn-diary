---
date: 2025-05-11
tags:
  - "#线段树"
---


# 前言

[从线段树二分的角度，带你发明线段树【力扣周赛 440】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV15gRaYZE5o/?vd_source=145426a3203c4e7cb072084f20109921)

[3479. 将水果装入篮子 III - 力扣（LeetCode）](https://leetcode.cn/problems/fruits-into-baskets-iii/description/)

注：普通线段树适用于单点更新的情况，如果需要区间更新，就得用lazy线段树


# 线段树的由来-为什么要这样设计线段树？

3479\. 将水果装入篮子 III
------------------

给你两个长度为 `n` 的整数数组，`fruits` 和 `baskets`，其中 `fruits[i]` 表示第 `i` 种水果的 **数量**，`baskets[j]` 表示第 `j` 个篮子的 **容量**。

你需要对 `fruits` 数组从左到右按照以下规则放置水果：

*   每种水果必须放入第一个 **容量大于等于** 该水果数量的 **最左侧可用篮子** 中。
*   每个篮子只能装 **一种** 水果。
*   如果一种水果 **无法放入** 任何篮子，它将保持 **未放置**。

返回所有可能分配完成后，剩余未放置的水果种类的数量。


## 分析

首先，考虑暴力做法，每次从fruit数组中取出一个数字，假设这个数学是6，我们就要在basket中找到从左侧开始第一个>=6的数字。这样时间复杂度显然是$O(n^2)$.

如何优化呢？

我们用一个例子来看：

basket 3 1 4 1 5 9 2 6

找第一个>=6的数字

首先，我们知道想要优化查找，那么最好的办法是用**二分**，但是，我们的数组是无序的，也不准排序，这时又该怎么办呢？

我们再观察下数组，假设我们把他分成两部分，3 1 4 1 和 5 9 2 6，我们可以根据这两部分的**最大值**来判断**哪个部分有>=6的数字**，可知第二部分有，那我们就可以直接不看第一部分了。

接着，再把第二部分又分为两部分，看两部分的最大值，我们就得出了一个答案。

现在，我们来整理整理，运用这种**分治**的思想。

我们把**相邻的数字维护出最大值**，然后前四个数再得出最大值，后四个数再得出最大值，最后我们可以建出一个**二叉树**,然后用这个二叉树**拿来递归查询**，就能快速的得出答案了。

综上，我们可以知道，**线段树就是一个采用了分治的数据结构**


## 本题线段树操作

1. 我们要用最大值来建树
2. 假如有符合条件的最大值，该叶子节点要改为-1，此时叶子节点的所有祖父节点都要进行**更新**






# 线段树时间复杂度

1. 初始化:$O(n)$(节点有2n-1个)(数组容量开$n \times 4$绝对够)
2. 查询和更新:$O(n \log n)$



# 具体实现

- 如何解决节点索引（我们用一个**一维数组存储所有节点**）
  我们采用一个参数o作为任意节点，他的左子节点就是$2 \times o$,右子节点为$2 \times o + 1$,我们默认参数o从**1**开始
- 如何**分治递归建树**
  我们采用两个参数l,r。初始时，l=0,r=n-1,递归出口是，当l=r，那么当前**节点的最大值就是他自己**。

```cpp
	void maintain(int o)

    {

        mx[o] = max(mx[o * 2], mx[o * 2 + 1]);

    }

    void build(const vector<int> &a, int o, int l, int r)

    {

        if (l == r)

        {

            mx[o] = a[l];

            return;

        }

        int m = (l + r) / 2;

        build(a, o * 2, l, m);

        build(a, o * 2 + 1, m + 1, r);

        maintain(o);

    }
```

- 如何查询节点并更新
  
```cpp
int queryandupdate(int o, int l, int r, int x)

    {

        if (mx[o] < x)

        {

            return -1;

        }

        if (l == r)

        {

            mx[o] = -1;

            return l;

        }

        int m = (l + r) / 2;

        int i = queryandupdate(o * 2, l, m, x); // 优先查询左子树

        if (i == -1)                            // 如果左子树没有找到符合条件的节点，则查询右子树

        {

            i = queryandupdate(o * 2 + 1, m + 1, r, x);

        }

        maintain(o); // 维护节点的最大值,进行更新

        return i;

    }
```



